/***************************************************************/
/* Copyright 2025 Xenon Emulator Project. All rights reserved. */
/***************************************************************/

#pragma once

#include <memory>

#include "Core/RAM/RAM.h"
#include "Core/XCPU/eFuse.h"
#include "Core/XCPU/IIC/IIC.h"
#include "Core/XCPU/XenonSOC.h"
#include "Core/RootBus/RootBus.h"
#include "Core/XCPU/XenonReservations.h"

namespace Xe::XCPU {

  // Main Xenon CPU 'context'
  // Contains all of the internal CPU components and SOC logic aside from the Power Processing Elements and is shared 
  // for all three PPE's an their respecting Power Processing Units (PPU's) threads.
  struct XenonContext {
    XenonContext(RootBus* rootBusPtr, RAM* ramPtr) : rootBus(rootBusPtr), ram(ramPtr) {}
    ~XenonContext() {
      rootBus.reset();
      ram.reset();
    }

    // Xenon SecureROM
    // Contains the CPU's main startup code known as 1BL.
    u8* SROM = new u8[XE_SECROM_BLOCK_SIZE];

    // Xenon SecureRAM
    // The SRAM is used during the early boot process for the CPU to decrypt the second stage booloader on the system.
    // It is also used in conjuction with the Xenon's 'Security Engine' for cryptographic purposes (Holds the keyset 
    // generated by it).
    u8* SRAM = new u8[XE_SECRAM_BLOCK_SIZE];

    // Xenon eFuses
    // Each Xenon CPU has a built-in One-Time-Programmable storage (768 bits) that contains per-cpu data and security
    // flags, these include:
    // * Console type (Devkit/Retail)
    // * SB/CB (Second stage bootloaders (Devkit/Retail respectively)) 'lockdown value'.
    // * CPU 'Key'. A 16 byte string that it's used during the boot process for cryptographic and security purposes.
    // * SD/CD (Kernel) 'lockdown value'. 
    eFuses fuseSet = {};

    // Xenon Integrated Interrupt Controller
    // This is a built-in interrupt controller that holds and coordinates interrupts betweeen the PPU's and the 
    // external system peripherals.
    IIC::XenonIIC xenonIIC = {};

    // Used for conditional load/store instructions regarding PowerPC atomic operations.
    XenonReservations xenonRes = {};

    // Time Base switch, possibly RTC register, the TB counter only runs if this
    // value is set.
    bool timeBaseActive = false;

    // RAM/RootBus getters.
    RootBus* GetRootBus() { return rootBus.get(); }
    RAM* GetRAM() { return ram.get(); }

    // Xenon SOC Blocks R/W methods.
    bool HandleSOCRead(u64 readAddr, u8* data, size_t byteCount);
    bool HandleSOCWrite(u64 writeAddr, const u8* data, size_t byteCount);

    //
    // SOC Blocks.
    // 

    // Secure OTP Block.
    std::unique_ptr<SOC::SOCSECOTP_ARRAY> socSecOTPBlock = std::make_unique<SOC::SOCSECOTP_ARRAY>();

    // Security Engine Block.
    std::unique_ptr<SOC::SOCSECENG_BLOCK> socSecEngBlock = std::make_unique<SOC::SOCSECENG_BLOCK>();

    // Secure RNG Block.
    std::unique_ptr<SOC::SOCSECRNG_BLOCK> socSecRNGBlock = std::make_unique<SOC::SOCSECRNG_BLOCK>();

    // CBI Block.
    std::unique_ptr<SOC::SOCCBI_BLOCK> socCBIBlock = std::make_unique<SOC::SOCCBI_BLOCK>();

    // PMW Block.
    std::unique_ptr<SOC::SOCPMW_BLOCK> socPMWBlock = std::make_unique<SOC::SOCPMW_BLOCK>();

    // Pervasive Block.
    std::unique_ptr<SOC::SOCPRV_BLOCK> socPRVBlock = std::make_unique<SOC::SOCPRV_BLOCK>();

  private:

    // Mutex for thread safety.
    std::recursive_mutex mutex;

    // RootBus pointer.
    std::shared_ptr<RootBus> rootBus;

    // RAM pointer.
    std::shared_ptr<RAM> ram;

    // SOC Blocks R/W.

    // Security Engine Block.
    bool HandleSecEngRead(u64 readAddr, u8* data, size_t byteCount);
    bool HandleSecEngWrite(u64 writeAddr, const u8* data, size_t byteCount);

    // Secure OTP Block.
    bool HandleSecOTPRead(u64 readAddr, u8* data, size_t byteCount);
    bool HandleSecOTPWrite(u64 writeAddr, const u8* data, size_t byteCount);

    // Secure RNG Block.
    bool HandleSecRNGRead(u64 readAddr, u8* data, size_t byteCount);
    bool HandleSecRNGWrite(u64 writeAddr, const u8* data, size_t byteCount);

    // CBI Block.
    bool HandleCBIRead(u64 readAddr, u8* data, size_t byteCount);
    bool HandleCBIWrite(u64 writeAddr, const u8* data, size_t byteCount);

    // PMW Block.
    bool HandlePMWRead(u64 readAddr, u8* data, size_t byteCount);
    bool HandlePMWWrite(u64 writeAddr, const u8* data, size_t byteCount);

    // Pervasive logic Block.
    bool HandlePRVRead(u64 readAddr, u8* data, size_t byteCount);
    bool HandlePRVWrite(u64 writeAddr, const u8* data, size_t byteCount);
  };
}